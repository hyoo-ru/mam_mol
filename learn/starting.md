# Quick start

## Setup your editor

- Use MAM directory as root of your project in editor
- [Install VScode intellisense plugin for *.view.tree files](https://marketplace.visualstudio.com/items?itemName=valikov.tree-language-service)
- [Install plugin for *.tree files](https://github.com/nin-jin/tree.d#ide-support)
- [Install .editorconfig plugin](https://editorconfig.org/#download) or use these preferences: **TABs for indents, LF for line endings**.

## Create MAM project

The easiest way is to checkout this [preconfigured MAM repository](http://github.com/hyoo-ru/mam) and start a dev server:

```sh
git clone https://github.com/hyoo-ru/mam.git ./mam && cd mam
npm install && npm start
```

## Create your application component

Examples use namespace `my` and application name `hello`, but you can use your own namespace and application name.

Add **web entry point** at `./my/hello/index.html`:

```html
<!-- Disable quirks mode -->
<!doctype html>

<!-- Allow height:100% in body -->
<html style=" height: 100% ">

<!-- Force utf-8 encoding -->
<meta charset="utf-8" />
	
<!-- Disable mobile browser auto zoom, $mol is adaptive -->
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1" />
	
<!-- autobind component to element on load -->
<body mol_view_root="$my_hello">

<!-- link to autogenerated js bundle -->
<script src="web.js"></script>
```

In the attribute `mol_view_root` we specified the name of the component to be mounted in the DOM-tree.

Add [**declarative component description**](../view/readme.md) at `./my/hello/hello.view.tree` with string input field and greeting message:

```tree
$my_hello $mol_view
	sub /
		<= Name $mol_string
			hint \Name
			value?val <=> name?val \
		<= message \
```

The code above will be automatically compiled to typescript code like this:

```typescript
namespace $ {
	export class $my_hello extends $mol_view {

	/// name?val \
	@ $mol_mem
	name( next = '' ) {
		return next
	}

	/// Name $mol_string 
	/// 	hint \Name
	/// 	value?val <=> name?val
	@ $mol_mem
	Name() {
		const obj = new $mol_string
		obj.hint = () => "Name" ,
		obj.value = next => this.name( next ) ,
		return obj
	}

	/// message \
	message() {
		return ""
	}

	/// sub / 
	/// 	<= Name
	/// 	<= message
	sub() {
		return [ this.Name() , this.message() ]
	}

} }
```

Take a minute to think about the correlation between the `view.tree` description and the generated class. `sub` is what is usually called `children` - i.e., nested components.

The `$mol_mem` decorator turns the method into a smart state container. It caches the result of the method, automatically clearing the cache when it becomes obsolete. Methods with this decorator are called reactive properties.

Method `name(next='')` with decorator `$mol_mem` is the same as `const [name, setName] = useState('')`, with channel interface: `this.name()` will return current value, `this.name('jin')` will set new value.

View-component starts with a declarative description in `view.tree` language, from which the builder generates a typescript class. The generated class is located in the "-view.tree" folder. Folders whose names begin with a minus sign contain build artifacts.

1. Follow **`http://localhost:9080`**
1. Open the developer tools and disable caching on the network tab. 
1. Select the **my** folder, then the **hello** folder.
1. This will start to build the application, and then you will see the component you just created.


To add view-component behavior, we must create a new class, with the same name, and inherit from the generated class. In this class, we can add the behavior.

Add **your behaviour** at `./my/hello/hello.view.ts` by extending generated class:

```typescript
namespace $.$$ {
	export class $my_hello extends $.$my_hello {
		
		override message() {
			let name = this.name()
			return name && `Hello, ${name}!`
		}
		
	}
}
```
In `view.tree` we have described the `message` property that returns an empty string. Now we override it so that it outputs `Hello` and value entered in the text field.

Note that we have used the namespace `$.$$`. There are two typescript namespaces `$` and `$$`. The generated class uses `$`. We add the behavior (styles, tests) to `$.$$`. This allows us to use the same name for different parts of the same component. For the purpose of namespaces, see the DI section.

Add **styles** at `./my/hello/hello.view.css.ts`:

```typescript
namespace $.$$ {

	const { rem } = $mol_style_unit

	$mol_style_define( $mol_app_hello , {
		display: 'flex',
		flex: {
			direction: 'column',
			shrink: 1,
			grow: 1,
			basis: 'auto',
		},
		alignItems: 'center',
		alignSelf: 'stretch',

		margin: 0,

		font: {
			family: 'sans-serif',
			size: rem(1.5),
		},
		boxShadow: '0 0 0 1px var(--mol_theme_line)',
		
		// Nested component we defined as Name in `view.tree`
		Name: {
			margin: rem(1),
			width: rem(14),	
			flex: {
				grow: 0,
			},
		},
	} )

}
```
Now is the transition to css in ts (this is not the same as the popular css in js). But you can also create `hello.view.css` and use css.

Add **tests for your behaviour** at `./my/hello/hello.test.ts`

```typescript
namespace $.$$ {

	$mol_test({

		'Generating greeting message'() {

			const app = new $my_hello
			app.name( 'Jin' )

			$mol_assert_equal( app.message() , 'Hello, Jin!' )

		}

	})

}
```

[That is all!](https://mol.js.org/app/hello/-)

## What's next

[Concepts](./concepts.md)
